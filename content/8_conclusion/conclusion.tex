\chapter{Conclusion}\label{chap:conclusion}
%Over all
Although some of the functionality have not achieved their goal, the result works as a proof of concept. It is is able to transfer data.

%Physical layer
The physical layer seem to be stable and can transfer frames flawless with the right settings. According to Table \ref{tab:exp_phys_speaker} a bit rate around $110\,\sfrac{bit}{s}$ can be reached without compromising the reliability of transmission of data. 

%Data link layer
The data link layer is able to process a packet and enclose it in a sequence of frames to be sent. It is also able to receive frames and to process them into at packet to be delivered to the transport layer. The data link layer is also able to control a token based network in a way that allows collision free half duplex communication. 

%The data link layer performed well under test and handles communication with up to sixty percent errors, though this amount of errors makes it very slow. With more than sixty percent errors all time goes into control frames and almost no frames are transmitted.
% Data link layer diskussion ?????
%If it is possible to find a way of using a sliding window instead of the eight byte list currently implemented. There is currently a lot of transmission time being wasted in sending lists shorter than eight entries. Other changes could be considered to handle cases where a crucial frame is lost. For example the case where a reply is lost which results in some waiting time and the entire list being resend.

%Transport
The transport layer was successfully able to reliably handle packets. The checksum was calculated correctly and used to verify the content of the packets. Retransmitting packets, if contents proved to be wrong, was possible. %Improvement could be made in the data transfer to- and from the transport layer protocol, but it is not highly necessary in this part of the protocol, as speed does not seem to be an issue. Rather, the ability to correctly deliver data to the API in the right order would be the criteria of success.

%Backbone
The backbone class works as expected. It is able to dispatch work to the correct layer objects, based on the state of the internal buffers and layers.

%The backbone has not been tested, as it is meaningless to test it without the actual layers combined. Since the final assembly has not been completed at the time of writing, any backbone tests are impossible. However the backbone has been debugged and everything seems to be functioning properly.
%Backbone diskussion????
%The input and output stacks could have their own backbone thread, in order to simplify the logic of which buffer to check. The communication to the physical layer could be handled through an actual queue with a mutex on the last element, instead of a ring buffer. The logic to detect whether the network layer and data link layer have room to perform their actions needs to be improved.

%API
The API layer has only been tested for functionality as it was not possible to make any performance test on this layer. It is able to create user messages and pass these on to the correct buffers without making threading problems. %The messages can be picked up by the backbone and send to the transport. It has also been tested that the API layer is able to receive data from the backbone, and call the user defined callback method. The API layer could be improved by extending the feedback functionality such as notification about the quality of the link and whether a message has been send or still is queued. These functionalities would of cause require the protocol layers to provide these informations to the API layer.

%Test program
The test function worked as intended. It was used for many different tests, because it could be modified to fit specific requirements. Unfortunately not all parts of the stack were tested as intended with this functionality, which was due to miscommunication in the group. Adding more options to the test tool would increase the versatility of it.

%Conclusion for real
Overall this project is a success as every layer have been tested and is working as intended. Assembling the layers into a protocol stack with the API on top have proven to cause some trouble. At the time of this writing a complete protocol stack with an API is not implemented fully as a working library.